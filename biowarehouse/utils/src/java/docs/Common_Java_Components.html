<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <title>Common Java Components</title>
</head>
<body>
<h2 style="text-align: center;">Warehouse Common Java Components</h2>
<div style="text-align: center;">Modified: $Date: 2006/07/06 20:17:13 $<br>
</div>
<br>
<h3>
<a href="#Overview">Overview<br>
</a><a href="#How_to_Build_the_Components">How to Build the Components</a><br>
<a href="#How_to_Use_the_Components">How to Use the Components</a><br>
<a href="#Testing">Testing</a></h3>
JDBC Issues<br>
<br>
<h3><a name="Overview"></a>Overview</h3>
Several of the Java-based loaders (GenBank, Uniprot, Enumerations) use
a set of common reusable components located in the <code>common/</code>
directory of the Warehouse distribution..&nbsp; These components
consist of classes that can manage to the connection to the Warehouse
database and classes that represent a Java binding of the database
schema.&nbsp; The Javadoc API documentation can be viewed <a
 href="api/index.html">here</a>.<br>
<br>
<h3><a name="How_to_Build_the_Components"></a>How to Build the
Components</h3>
The common components are packaged into a single jar file (<code>dist/warehouse-{version}.jar</code>)
that is included in the classpath by the client loaders.&nbsp; Each
client loader build file calls the <code>build </code>target of the
common build file before compiling or executing the loader source code.<br>
<br>
<h3><a name="How_to_Use_the_Components"></a>How to Use the Components</h3>
A simple example of how to use the common Java components to access the
Warehouse is provided at <code>com.sri.biospice.warehouse.database.WarehouseExample</code>.&nbsp;
The <code>Warehouse </code>class is a Singleton and needs to be
initialized just once via <code>WarehouseManager.initWarehouse()</code>.&nbsp;
Thereafter, the <code>Warehouse </code>class may be accessed via the
static factory method <code>WarehouseManager.getWarehouse()</code>.&nbsp;
<br>
<br>
The <code>WarehouseManager </code>constructs either a <code>MySQLWarehouse</code>,
<code>OracleWarehouse</code>, or <code>NullWarehouse </code>object,
depending on the initialization parameters.&nbsp; Although the <code>NullWarehouse
</code>class is intended to be used as a mock object (a "null" database
connection), many of the schema classes rely on being able to obtain
real <code>TableMetaData </code>from a real database.&nbsp; Hence the
<code>NullWarehouse </code>cannot be used in a running application at
this time.&nbsp; (It is intended to be used for testing and running
loaders without requiring a true database connection.&nbsp; We intend
to remove this restriction in the future, as time permits.)<br>
<h5>Table classes</h5>
The classes in <code>com.sri.biospice.warehouse.database.table</code>
represent single entries in a single column in a single table.&nbsp;
These classes know how to set their respective parameters in a <code>PreparedStatement
</code>used to insert data into the schema tables.&nbsp; In addition,
these classes provide error checking.&nbsp; For example, the <code>StringColumn
</code>class can check that the value to be inserted into a column does
not exceed the allowed column size.<br>
<h5>Schema classes</h5>
The classes in <code>com.sri.biospice.warehouse.database.schema</code>
and subpackages represent a Java binding of the Warehouse schema.&nbsp;
Each Warehouse table is represented by a single Java class, with
accessor methods corresponding to the columns of the table.&nbsp; For
example, the <code>Protein </code>class has <code>setName()</code>
and <code>getName()</code> methods.&nbsp; All inserts into tables are
performed via pre-compiled JDBC <code>PreparedStatements</code>.&nbsp;
The tables may represent new entries into a table or existing entries
in the Warehouse.&nbsp; Methods are provided to store, load, update, or
delete an entry in a table.&nbsp; Each instance of a schema class
represents one row in one table.<br>
<br>
The schema classes may be divided into three categories:&nbsp; object
tables, linking tables, and other tables.&nbsp; The object table
classes implement the <code>ObjectTable </code>interface and
represent all tables that have a WID column (tables that represent real
objects in the Warehouse schema).&nbsp; Each linking table (a table
that defines a linking relationship between two object tables) is
defined by its own class, but clients may use the more convient <code>LinkingTables
</code>class, which provides methods for each type of linking
table.&nbsp; The remaining tables do not have any other common defining
features.<br>
<br>
The schema classes are kept up-to-date with the Warehouse schema.&nbsp;
Any change to the schema definition (change in number or type of
columns) requires a corresponding change to the Java class representing
that table.&nbsp; Any change to the listing of allowed enumerated
values (values loaded into the Enumeration table by the Enumerations
loader) require a corresponding change in the Java source code for that
class.<br>
<br>
<h3><a name="Testing"></a>Testing</h3>
The common java components are covered by a set of unit and functional
tests located in the <code>common/test/</code> directory.&nbsp; Most
of the unit tests require a live connection to an instance of the
warehouse.&nbsp; Many of the unit tests DO modify the data in the
warehouse database, so be sure the testing parameters are set to
connect to a database designated for testing.&nbsp; The connection
parameters for the unit tests must be defined in <code>common/test/unittest.properties</code>.&nbsp;
A template file is provided at <a
 href="../test/unittest.properties.template"><code>common/test/unittest.properties.template</code></a>.&nbsp;
In particular, the <code>EnumeratedValues_Test</code> checks to see
that the number and type of enumerated values defined for each table
(Java class) matches what is loaded in the Enumeration table of the
database.<br>
<br>
The tests are run by first editing the <code>unittest.properties</code>
file and then invoking the <code>test </code>Ant target.<br>
<br>
<br>
<h3>JDBC Issues</h3>
The Java Warehouse loaders all support both Oracle and MySQL Database
Management Systems (DBMS).&nbsp; In most cases, the warehouse source
code uses DBMS-neutral (generic JDBC) code.&nbsp; There are two areas
where the two DBMSs must be handled differently: connection parameters
and the selection of WIDs (Warehouse Identifiers).&nbsp; <br>
<br>
Developers using JDBC to connect to a number of different DBMSs should
be aware of the limitations and known issues of each JDBC driver
implementation.<br>
<br>
<ul>
  <li>The MySQL JDBC driver is known as Connector/J.&nbsp;
Documentation can be found <a
 href="http://dev.mysql.com/doc/connector/j/en/index.html">here</a>.</li>
</ul>
<ul>
  <li>Oracle has two JDBC drivers.&nbsp; <br>
  </li>
  <ul>
    <li>The "thin" client is a 100% Java implementation that can be
used by any client.</li>
    <li>The "thick" or "oci" client requires a client-side Oracle
client.</li>
    <li><a
 href="http://www.oracle.com/technology/software/tech/java/sqlj_jdbc/htdocs/jdbc_readme101020.html">Release
notes</a> for the Oracle 10g JDBC drivers</li>
    <li><a
 href="http://www.oracle.com/pls/db10g/portal.portal_demo3?selected=5">Documentation
      </a>for Oracle 10g, including sections on JDBC<br>
    </li>
  </ul>
</ul>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<ul>
</ul>
</body>
</html>
