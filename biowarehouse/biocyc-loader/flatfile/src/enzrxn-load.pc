/* *******************************************************************
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and
 * limitations under the License.
 *
 * The Original Code is the BioWarehouse.
 *
 * The Initial Developer of the Original Code is SRI International.
 * Portions created by SRI International are Copyright (C) 2004.
 * All Rights Reserved.
 ******************************************************************* */
/*
 * PGDB ENZRXN loader for the BioSpice Data Warehouse
 * Thomas J Lee, SRI International, August 2002
 */

#include "main.h"
#include "enzrxn-parse.h"
#ifdef ORACLE
#include <sqlca.h>
#endif

#define DEBUG 0

extern int dataset_wid;


int
find_enzrxn(char *name) {
  return(db_select_enzrxn(name));
}

// Made obsolete in 11.5 since these are in regulation.dat
//void
//insert_enzrxn_compounds(struct enzrxn_entry *entry,
//			int enzrxn_wid,
//			struct stringlist* compound_names,
//			char mechanism,
//			char inhibit_or_activate) {
//  /*
//    Add a row to the EnzReactionInhibitorActivator table for each compound in list of names.
//    Each name is a chemical compound that is defined in compounds file, proteins file, or
//    is undefined due to limitations in the source DB. In the latter case, the name is
//    assumed to be a coompound and is added to the Chemical table.
//  */
//  struct stringlist *sptr, *commptr;  
//  for (sptr=compound_names; sptr; sptr=sptr->next) {
//    int compound_wid = obtain_enzrxn_compound(sptr->string, 1);
//    char physiologically_relevant = stringlist_find(sptr->string, entry->physio_relevants) ? 'T' : 'F';
//    wh_insert_enzrxn_chemical(enzrxn_wid, compound_wid, mechanism, inhibit_or_activate, physiologically_relevant);
//  }
//}

void
insert_enzrxn_cofactors(struct enzrxn_entry *entry,
			int enzrxn_wid,
			struct stringlist* cofactor_names,
			char prosthetic, short prosthetic_ind) {
  /*
    Add a row to the EnzReactionCofactor table for each cofactor in list of names.
    Each name is a chemical compound that should have been defined in compounds file.
  */
  struct stringlist *sptr, *commptr;  
  for (sptr=cofactor_names; sptr; sptr=sptr->next) {
    int chemical_wid = obtain_enzrxn_compound(sptr->string, 0);
    wh_insert_enzrxn_cofactor(enzrxn_wid, chemical_wid, prosthetic, prosthetic_ind);
  }
}
			
void
insert_enzrxn_alternates(struct enzrxn_entry *entry,
			 int enzrxn_wid,
			 struct stringlist* compound_names,
			 char cofactor) {
  /*
    Add a row to the EnzReactionAltCompound for each alternate in given list.
    Each name is a chemical compound that is defined in compounds file or
    is undefined due to limitations in the source DB. In the latter case, the name is
    assumed to be a compound and is added to the Chemical table.
    The first name is the primary, subsequent names are alternates to it.
  */
  struct stringlist *sptr, *commptr;
  int primary_wid = obtain_enzrxn_compound(compound_names->string, 0);
  for (sptr=compound_names->next; sptr; sptr=sptr->next) {
    int alternate_wid = obtain_enzrxn_compound(sptr->string, 0);
    wh_insert_enzrxn_alternate(enzrxn_wid, primary_wid, alternate_wid, cofactor);
  }
}


void
enzrxn_load_entry(struct enzrxn_entry *entry) {

  int enzrxn_wid = wh_get_new_wid();
  struct stringlist *sptr;           /* to iterate over synonyms */
  
  int reaction_wid = find_reaction(entry->reaction);
  int protein_wid = find_protein(entry->enzyme);
  int complex_wid = find_protein(entry->complex);
  
  /* Set indicator variables for optional columns, and check string lengths, numeric formats etc. */
  short complex_ind; 
  char *complex = string_column(entry->complex, 50, &complex_ind);
  short reaction_direction_ind; 
  char *reaction_direction = string_column(entry->reaction_direction, 30, &reaction_direction_ind);

  if (!entry)
    advise_error("Null entry passed to enzrxn_load_entry\n");
  if (DEBUG)
    printf("Loading enzrxn %s\n", entry->unique_id);
    
  if (protein_wid == 0) {
    enzrxn_parse_error();
    printf("*** Enzyme %s not found for enzrxn - ignoring entry %s\n", entry->enzyme, entry->unique_id);
    return;
  }
  if (reaction_wid == 0) {
    enzrxn_parse_error();
    printf("*** Reaction %s not found for enzrxn %s - ignoring entry \n", entry->reaction, entry->unique_id);
    return;
  }

#ifdef ORACLE 
  /* Try a WHENEVER to assist in debugging silent Oracle errors */
  EXEC SQL WHENEVER SQLERROR DO sql_error("Oracle error in enzrxn-load");
#endif
  
  /* Insert row into Enzrxn table */
  wh_insert_enzymaticreaction(enzrxn_wid, reaction_wid, protein_wid,
			      complex_wid, complex_ind,
			      reaction_direction, reaction_direction_ind);

  /* Add non-prosthetic cofactors to EnzReactionCofactor tables */
  insert_enzrxn_cofactors(entry, enzrxn_wid, entry->cofactor_prosthetics, 'F', INDICATE_NONNULL);
      
  /* Add cofactor prosthetic groups to EnzReactionCofactor tables */
  insert_enzrxn_cofactors(entry, enzrxn_wid, entry->cofactor_unknowns, 'T', INDICATE_NONNULL);
      
  /* Add cofactors that may or may not be prosthetic groups to EnzReactionCofactor tables */
  insert_enzrxn_cofactors(entry, enzrxn_wid, entry->cofactors, '?', INDICATE_NULL);
  
  /* Add all activators/inhibitors to EnzReactionInhibitorActivator table.  */
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->allosteric_activators,     'A', 'A');
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->nonallosteric_activators,  'N', 'A');
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->unknown_activators,        'U', 'A');
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->unknown_inhibitors,        'U', 'I');
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->other_inhibitors,          'O', 'I');
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->noncompetitive_inhibitors, 'N', 'I');
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->competitive_inhibitors,    'C', 'I');
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->allosteric_inhibitors,     'A', 'I');
//  insert_enzrxn_compounds(entry, enzrxn_wid, entry->irreversible_inhibitors,   'I', 'I');
//  
  /* Add alternate compounds to EnzReactionAltCompounds */
  if (entry->alt_cofactors)
    insert_enzrxn_alternates(entry, enzrxn_wid, entry->alt_cofactors, 'T');
  if (entry->alt_substrates)
    insert_enzrxn_alternates(entry, enzrxn_wid, entry->alt_substrates, 'F');
  
  /* Add DB links to CrossReference */
  insert_dblinks(enzrxn_wid, entry->dblinks_dbs, entry->dblinks_ids);
    
  /* Add synonyms to SynonymTable  */
  wh_insert_synonymtable(enzrxn_wid, entry->common_name);  
  for (sptr=entry->synonyms; sptr; sptr=sptr->next)
    wh_insert_synonymtable(enzrxn_wid, sptr->string);

  /* Add citations to CitationWIDOtherWID  */
  for (sptr=entry->citations; sptr; sptr=sptr->next)
    insert_citation(enzrxn_wid, sptr->string);

  /* Add comments to CommentTable  */
  for (sptr=entry->comments; sptr; sptr=sptr->next)
    wh_insert_comment(enzrxn_wid, sptr->string);
  for (sptr=entry->cofactor_comments; sptr; sptr=sptr->next) /* These are also assoc with EnzReactionCofactor entries */
    wh_insert_comment(enzrxn_wid, sptr->string);

  /* Add DBID */
  if (!entry->unique_id)
    entry->load_error = 1;
  else
    wh_insert_dbid(enzrxn_wid, entry->unique_id);
  
  /* Finally add Entry */
  wh_insert_entry(enzrxn_wid, entry->load_error, 0, NULL);
}
