/* *******************************************************************
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and
 * limitations under the License.
 *
 * The Original Code is the BioWarehouse.
 *
 * The Initial Developer of the Original Code is SRI International.
 * Portions created by SRI International are Copyright (C) 2004.
 * All Rights Reserved.
 ******************************************************************* */
/*
 * PGDB PROMOTER loader for the BioSpice Data Warehouse
 * Thomas J Lee, SRI International, August 2002
 */

#include "main.h"
#include "promoter-parse.h"
#ifdef ORACLE
#include <sqlca.h>
#define COMMON_NAME_MAXLEN 1300
#elif DEF_MYSQL
#define COMMON_NAME_MAXLEN 1300
#elif DEF_POSTGRES
#define COMMON_NAME_MAXLEN 1300
#endif

#define DEBUG 0

extern int dataset_wid;
extern int organism_wid;
short ind;

void
promoter_load_entry(struct promoter_entry *entry) {

  int feature_wid;
  int parent_wid;      // parent component, if defined
  short error = 0;
  short convert_error; // numeric conversion errors
  short pos_ind;       // is position attribute present?
  double dpos;
  int position;
  struct stringlist *sptr;           /* to iterate over synonyms */
  
  /* Set indicator variables for optional columns, and check string lengths, numeric formats etc. */
  char * common_name = string_column(entry->common_name, COMMON_NAME_MAXLEN, &entry->common_name_ind);

  if (DEBUG)
    printf("Loading promoter %s\n", entry->unique_id);
    
  // Convert position string to an integer
  convert_error = 0;
  pos_ind = INDICATE_NONNULL; // Don't report conversion error twice
  dpos = number_column(entry->absolute_plus1_pos, &pos_ind, &convert_error);
  position = ifloor(dpos, &convert_error);
  if (position != iceil(dpos, &convert_error)) // check position is integral
    convert_error = 1;
  if (convert_error) {
    printf("*** Error: conversion of position %s for %s\n",
           entry->absolute_plus1_pos, entry->unique_id);
    error = 1;
  }
  
  if (!entry)
    advise_error("Null entry passed to promoter_load_entry\n");
  if (entry->common_name != common_name) {
    printf("*** Warning: COMMON-NAME of %s truncated to length %d - %s\n",
	   entry->unique_id, COMMON_NAME_MAXLEN, common_name);
    error = 1;
  }

  if (error)
    promoter_parse_error();

#ifdef ORACLE  
  /* Try a WHENEVER to assist in debugging silent Oracle errors */
  EXEC SQL WHENEVER SQLERROR DO sql_error("Oracle error in promoter-load");
#endif

  feature_wid = wh_get_new_wid();
  
  // Remember this promoter position so components can be associated with 
  if (!convert_error)    // remember position-unique_id association to convert dnabindsites 
    widtable_insert(promoter_positions, position, entry->unique_id); 
  
  if (!common_name)
    common_name = entry->unique_id;
  
  db_insert_into_feature(feature_wid, "promoter", "point", "center",
                         common_name, entry->common_name_ind,
                         position, pos_ind, position, pos_ind);
  
  // Look up each parent component. If it is a transcription unit, link it to this promoter.
  // Else ignore it (eg. DNA complexes).
  for (sptr=entry->component_of; sptr; sptr=sptr->next) {
    parent_wid = find_transunit(sptr->string);
    if (parent_wid)
      wh_insert_transcription_unit_component(parent_wid, feature_wid, "promoter");
  }
  
  
  /* Add synonyms to SynonymTable  */
  for (sptr=entry->synonyms; sptr; sptr=sptr->next)
    wh_insert_synonymtable(feature_wid, sptr->string);

  /* Add citations to CitationWIDOtherWID  */
  for (sptr=entry->citations; sptr; sptr=sptr->next)
    insert_citation(feature_wid, sptr->string);

  /* Add comments to CommentTable  */
  for (sptr=entry->comments; sptr; sptr=sptr->next)
    wh_insert_comment(feature_wid, sptr->string);

  /* Add DBID */
  if (!entry->unique_id)
    entry->load_error = 1;
  else
    wh_insert_dbid(feature_wid, entry->unique_id);
  
  /* Insert all DBLINKS as crossreferences */      
  insert_dblinks(feature_wid, entry->dblinks_dbs, entry->dblinks_ids);
      
  /* Finally add Entry */
  wh_insert_entry(feature_wid, entry->load_error, 0, NULL);
}
