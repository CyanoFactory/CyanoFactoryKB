/* *******************************************************************
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and
 * limitations under the License.
 *
 * The Original Code is the BioWarehouse.
 *
 * The Initial Developer of the Original Code is SRI International.
 * Portions created by SRI International are Copyright (C) 2004.
 * All Rights Reserved.
 ******************************************************************* */
/*
 * PGDB PROTEIN loader for the BioSpice Data Warehouse
 * Thomas J Lee, SRI International, August 2002
 */

#include "main.h"
#include "protein-parse.h"
#ifdef ORACLE
#include <sqlca.h>
#define COMMON_NAME_MAXLEN 4000
#elif DEF_MYSQL
#define COMMON_NAME_MAXLEN 65535
#endif

#define DEBUG 0

extern int dataset_wid;
extern int organism_wid;
short ind;

void
protein_load_entry(struct protein_entry *entry) {

  int protein_wid;
  int subunit_wid;
  int term_wid;
  short error = 0;                   /* numeric conversion error */
  struct stringlist *sptr;           /* to iterate over synonyms */
  struct stringlist *coeffptr;       /* to iterate over coefficients */
  struct stringlist *componentptr;   /* to iterate over components */
  double coefficient;
  short coeff_ind;
  
  /* Set indicator variables for optional columns, and check string lengths, numeric formats etc. */
  char * common_name = string_column(entry->common_name, COMMON_NAME_MAXLEN, &entry->common_name_ind);
  double pi_calc = number_column(entry->pi, &entry->pi_ind, &error);
  double molecular_weight_exp = number_column(entry->molecular_weight_exp, &entry->molecular_weight_exp_ind, &error);
  double molecular_weight = number_column(entry->molecular_weight, &entry->molecular_weight_ind, &error);

  if (!entry)
    advise_error("Null entry passed to protein_load_entry\n");
  if (entry->common_name != common_name) {
    printf("*** Warning: COMMON-NAME of %s truncated to length %d - %s\n",
	   entry->unique_id, COMMON_NAME_MAXLEN, common_name);
    error = 1;
    free(entry->common_name);
    entry->common_name = common_name;
  }
  if (error)
    protein_parse_error();

  if (DEBUG)
    printf("Loading protein %s\n", entry->unique_id);
#ifdef ORACLE  
  /* Try a WHENEVER to assist in debugging silent Oracle errors */
  EXEC SQL WHENEVER SQLERROR DO sql_error("Oracle error in protein-load");
#endif

  
  /* Either Insert row into Protein table, or update existing row */
  /* Row will exist if this protein is a COMPONENT of a previously parsed protein */
  protein_wid = find_protein(entry->unique_id);
  if (protein_wid) {
    if (DEBUG) printf("Updating proteinWID %d\n", protein_wid);
    db_update_protein_full(protein_wid, entry, molecular_weight, molecular_weight_exp, pi_calc);
  }
  else {
    protein_wid = wh_get_new_wid();
    if (DEBUG) printf("Inserting proteinWID %d\n", protein_wid);
    widtable_insert(protein_wids, protein_wid, entry->unique_id);  /* remember wid-unique_id association */
    db_insert_into_protein(protein_wid, entry, molecular_weight, molecular_weight_exp);
  }
  
  /* Add to BioSourceWIDProteinWID table  */
  wh_insert_linktable("BioSourceWID", organism_wid, "ProteinWID", protein_wid);

  /* Add RelatedTerm for all GO term external IDs */
  for (sptr=entry->go_terms; sptr; sptr=sptr->next) {
    term_wid = wh_select_dbid_otherwid(sptr->string, go_dataset_wid);
    //-printf("GO Term=%s datasetwid=%d wid=%d\n", sptr->string, go_dataset_wid, term_wid);
    if (term_wid) {
      wh_insert_relatedterm(term_wid, protein_wid, "keyword", INDICATE_NONNULL);
      //-printf("Added link to GO RelatedTerm %s from protein %s\n", sptr->string, entry->unique_id);
    }
  }
 
  /* Add COMPONENT proteins to Subunit table  */
  coeffptr = entry->coeffs;
  for (componentptr=entry->components; componentptr; componentptr=componentptr->next) {
    if (DEBUG) printf("Adding subunit %s\n", componentptr->string);
    subunit_wid = find_protein(componentptr->string);
    if (!subunit_wid) {
      subunit_wid = wh_get_new_wid();
    if (DEBUG) printf("Inserting proteinWID for subunit %d\n", subunit_wid);
    wh_insert_bare_object("Protein", subunit_wid);
      widtable_insert(protein_wids, subunit_wid, componentptr->string);  /* remember wid-unique_id association */
    }
    error = 0;
    coefficient = number_column(coeffptr->string, &coeff_ind, &error);
    if (error || coeff_ind == INDICATE_NULL) {
      printf("Warning: Symbolic or invalid coefficient %s for %s, using 0\n",
	     coeffptr->string, componentptr->string);
      protein_parse_error();
      coefficient = 0.0;
    }
    
    /* Add Subunit entry */
    wh_insert_subunit(protein_wid, subunit_wid, (int) coefficient);
    
    coeffptr = coeffptr->next;  /* keep in correspondence with componentptr */
  }  
    
  /* Add synonyms to SynonymTable  */
  for (sptr=entry->synonyms; sptr; sptr=sptr->next)
    wh_insert_synonymtable(protein_wid, sptr->string);

  /* Add citations to CitationWIDOtherWID  */
  for (sptr=entry->citations; sptr; sptr=sptr->next)
    insert_citation(protein_wid, sptr->string);

  /* Add comments to CommentTable  */
  for (sptr=entry->comments; sptr; sptr=sptr->next)
    wh_insert_comment(protein_wid, sptr->string);

  /* Add locations to Location table */
  for (sptr=entry->locations; sptr; sptr=sptr->next)
    wh_insert_location(protein_wid, sptr->string);

  /* Add DBID */
  if (!entry->unique_id)
    entry->load_error = 1;
  else
    wh_insert_dbid(protein_wid, entry->unique_id);
  
  /* Insert all DBLINKS as crossreferences */      
  insert_dblinks(protein_wid, entry->dblinks_dbs, entry->dblinks_ids);
      
  /* Finally add Entry */
  wh_insert_entry(protein_wid, entry->load_error, 0, NULL);
}
